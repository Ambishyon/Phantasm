{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Phantasm UI Engine is a library/system designed to separate the creation of UIs and the programming of them. The way it works is by using a tree structure to represent all the elements and components in the interface, everything in the interface but Components are static. If you find anything missing from this documentation or that is incorrect, Open an issue on GitHub ! Info This documentation was made with the assumption you have some familiarity with Lua programming. If you're new to Lua, you should read some resources such as Programming in Lua by Roberto lerusalimschy and the documentation for Lua 5.0.","title":"Home"},{"location":"api-reference/","text":"Warning This documentation is currently incomplete and will be finished in the near future. For now, most of the important methods and constants have been documented. Methods \u00b6 Phantasm.createElement \u00b6 Phantasm.createElement(className, [props, [children]]) -> table Creates an Element data structure that describes information about how a Roblox Instance should look like that can be used within an interface. The children argument is a table specifying elements that are parented to this element. Caution Modifying props after they're passed to into createElement may result in unexpected behaviour, use a Component instead. Phantasm.createComponent \u00b6 Phantasm.createComponent(componentName, [props, [children]]) -> table Creates a Component data structure that describes information about how a Component should be displayed that can be used within an interface. Phantasm.mountInterface \u00b6 Phantasm.mountInterface(interfaceData, [parent]) -> PhantasmInterface Generates a PhantasmInterface object that will create and handle all the elements, components, and fragments as specified in the interfaceData argument. The resulting PhantasmInterface object can be interacted with nearly as if it were itself a Roblox Instance and can be passed to APIs like Phantasm.unmountInterface . It may also be used in the future for debugging APIs. Phantasm.demountInterface \u00b6 Phantasm.demountInterface(interface) -> void Destroys the given PhantasmInterface and all of its descendants. Does not work on a Roblox Instance and will also remove the interface from the render stack -- this must be given an interface that was returned by Phantasm.mountInterface . Constants \u00b6 Phantasm.Ref \u00b6 Use Phantasm.Ref as a key in the properties of an element or component to tell the engine to automatically set that element or component as the specified Ref's reference. More information about this can be found on this page . Phantasm.Event \u00b6 Index into Phantasm.Event to receive a key that can be used to connect to events when creating elements: Phantasm . createElement ( \"TextButton\" , { [ Phantasm . Event . Activated ] = function ( element , inputObject , clickCount ) print ( element , \"clicked with inputObject\" , inputObject , \"and count\" , clickCount ) end ; }) Info Event callbacks receive the Phantasm Element as the first parameter, followed by any parameters yielded by the event. Reference the events guide for further details. Phantasm.Changed \u00b6 Index into Phantasm.Changed to receive a key that can be used to connect to GetPropertyChangedSignal events. It functions similarly to Phantasm.Event : Phantasm . createElement ( \"TextButton\" , { [ Phantasm . Changed . AbsoluteSize ] = function ( element ) print ( \"TextButton absoluteSize changed to\" , element . AbsoluteSize ) end ; })","title":"API Reference"},{"location":"api-reference/#methods","text":"","title":"Methods"},{"location":"api-reference/#phantasmcreateelement","text":"Phantasm.createElement(className, [props, [children]]) -> table Creates an Element data structure that describes information about how a Roblox Instance should look like that can be used within an interface. The children argument is a table specifying elements that are parented to this element. Caution Modifying props after they're passed to into createElement may result in unexpected behaviour, use a Component instead.","title":"Phantasm.createElement"},{"location":"api-reference/#phantasmcreatecomponent","text":"Phantasm.createComponent(componentName, [props, [children]]) -> table Creates a Component data structure that describes information about how a Component should be displayed that can be used within an interface.","title":"Phantasm.createComponent"},{"location":"api-reference/#phantasmmountinterface","text":"Phantasm.mountInterface(interfaceData, [parent]) -> PhantasmInterface Generates a PhantasmInterface object that will create and handle all the elements, components, and fragments as specified in the interfaceData argument. The resulting PhantasmInterface object can be interacted with nearly as if it were itself a Roblox Instance and can be passed to APIs like Phantasm.unmountInterface . It may also be used in the future for debugging APIs.","title":"Phantasm.mountInterface"},{"location":"api-reference/#phantasmdemountinterface","text":"Phantasm.demountInterface(interface) -> void Destroys the given PhantasmInterface and all of its descendants. Does not work on a Roblox Instance and will also remove the interface from the render stack -- this must be given an interface that was returned by Phantasm.mountInterface .","title":"Phantasm.demountInterface"},{"location":"api-reference/#constants","text":"","title":"Constants"},{"location":"api-reference/#phantasmref","text":"Use Phantasm.Ref as a key in the properties of an element or component to tell the engine to automatically set that element or component as the specified Ref's reference. More information about this can be found on this page .","title":"Phantasm.Ref"},{"location":"api-reference/#phantasmevent","text":"Index into Phantasm.Event to receive a key that can be used to connect to events when creating elements: Phantasm . createElement ( \"TextButton\" , { [ Phantasm . Event . Activated ] = function ( element , inputObject , clickCount ) print ( element , \"clicked with inputObject\" , inputObject , \"and count\" , clickCount ) end ; }) Info Event callbacks receive the Phantasm Element as the first parameter, followed by any parameters yielded by the event. Reference the events guide for further details.","title":"Phantasm.Event"},{"location":"api-reference/#phantasmchanged","text":"Index into Phantasm.Changed to receive a key that can be used to connect to GetPropertyChangedSignal events. It functions similarly to Phantasm.Event : Phantasm . createElement ( \"TextButton\" , { [ Phantasm . Changed . AbsoluteSize ] = function ( element ) print ( \"TextButton absoluteSize changed to\" , element . AbsoluteSize ) end ; })","title":"Phantasm.Changed"},{"location":"advanced/fragments/","text":"WIP","title":"Fragments"},{"location":"advanced/portals/","text":"WIP","title":"Portals"},{"location":"guide/basic-interface/","text":"Info The following example assumes that you have successfully managed to install Phantasm into ReplicatedStorage Insert a new LocalScript instance into StarterPlayer.StarterPlayerScripts either via within Roblox Studio or via Rojo: local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Phantasm = require ( ReplicatedStorage . PhantasmEngine ) local interfaceData = { Functions = {}; Bindings = {}; Elements = { HelloWorld = { ClassName = \"TextLabel\" ; Properties = { Size = UDim2 . new ( 1 , 0 , 0 , 250 ); Text = \"Hello World!\" ; }; }; }; } local interface = Phantasm . mount ( interfaceData ) When you run this in your game, you should see a large label spanning across your screen with the words \"Hello World!\" appear!","title":"Basic Interface"},{"location":"guide/bindings-and-refs/","text":"In certain situations, Phantasm's process of managing properties is inadequite for managing some instance properties, and in cases where a property needs to change often, manually changing it via external code or a component is inefficient. Phantasm introduces Bindings and Refs for cases like this. Bindings and Refs are intended to be used in cases where Phantasm is unable to solve a problem directly or its solution might not be performant enough or ideal, such as: Invoking functions on Roblox instances Gamepad selection Dynamic properties Bindings \u00b6 Bindings are a objects that Phantasm uses to automatically evaluate and change the properties they have been subscribed to. When the engine determines that a binding's output has changed, it will automatically apply this change to the properties that have been subscribed to it. Properties \u00b6 Bindings can be specified either from a module in the engine's Bindings folder, the Bindings table within the interface, or from the shared Bindings folder in ReplicatedStorage.Phantasm . As a result of this, bindings can be given a set of properties to use when they are being evaluated. Binding a Property \u00b6 Bindings can be bound to a property with ease, simply define that property's value using a table format with the Type key being equal to Binding , the Name key being the name of the binding you want to use, and the Properties key, if present, being a table of properties to provide the binding at the time of evaluation. Alternatively, you can simplify this process by using Phantasm.createBinding() , which will create the data structure for you like so: { Element = { ClassName = \"TextLabel\" ; Properties = { Text = Phantasm . createBinding ( \"Name\" , {}) }; }; } Creating a Binding \u00b6 To create a binding, define a data structure with keys for the Properties , ReturnType , Category , Description , and Run function like so: { Properties = { FormatString = { Type = \"string\" ; Default = \"OS Time: %s\" ; }; }; ReturnType = \"string\" ; Category = \"Time\" ; Description = \"Returns a formatted os.time string\" ; Run = function ( element , arguments ) return string.format ( arguments . FormatString , tostring ( os.time ())) end ; } The reason why ReturnType , Category , and Description should be provided is because they tell Phantasm's editor what it should return, what category it should be in, and what to display when hovering over it for the description. These are useful because it allows you to guarantee that a UI designer will only apply this binding to properties that it will work on, and that the designer knows what they are intended for. Similarly, the reason you need to define values in Properties as a table with a Type and Default is so that the editor can handle these appropriately and make sure they don't result in a binding being incorrectly applied. Refs \u00b6 While bindings are incredibly helpful for individual properties, we may often want to access or reference an entire Roblox Instance and its methods, or provide a specific element to a component to be used for some purpose. Refs are a special object that point to either an element's Roblox Instance or the element itself depending on the context. A ref will point to an element's Roblox instance when being used as an element's property, while it will point to the element itself if it is being used as a property for a component, binding, or function. Refs in Action \u00b6 To use a ref, call Phantasm.createRef() and put the result somewhere persistent, such as within context or interfaceContext . An optional argument can also be provided to specify the element or the element's id to reference it to. { Init = function ( self , context , interfaceContext ) context . nextElement = phantasm . createRef () end ; } Finally, we create the elements in the component's Constructor . in NextElement, we use the special key Phantasm.Ref to allow us to tell the engine to automatically assign the reference at context.nextElement to NextElement so that it may be used by Element either in that call or the next (this depends on the order in which the elements are created). { Constructor = function ( self , context , interfaceContext ) return { Element = Phantasm . createElement ( \"TextButton\" , { NextSelectionLeft = context . nextElement ; }); NextElement = Phantasm . createElement ( \"TextButton\" , { [ Phantasm . Ref ] = context . nextElement ; }); } end ; } Info If you want to access a Ref from external code or via a higher/different component, you can specify it in the component's context and access it via componentName.Context","title":"Bindings and Refs"},{"location":"guide/bindings-and-refs/#bindings","text":"Bindings are a objects that Phantasm uses to automatically evaluate and change the properties they have been subscribed to. When the engine determines that a binding's output has changed, it will automatically apply this change to the properties that have been subscribed to it.","title":"Bindings"},{"location":"guide/bindings-and-refs/#properties","text":"Bindings can be specified either from a module in the engine's Bindings folder, the Bindings table within the interface, or from the shared Bindings folder in ReplicatedStorage.Phantasm . As a result of this, bindings can be given a set of properties to use when they are being evaluated.","title":"Properties"},{"location":"guide/bindings-and-refs/#binding-a-property","text":"Bindings can be bound to a property with ease, simply define that property's value using a table format with the Type key being equal to Binding , the Name key being the name of the binding you want to use, and the Properties key, if present, being a table of properties to provide the binding at the time of evaluation. Alternatively, you can simplify this process by using Phantasm.createBinding() , which will create the data structure for you like so: { Element = { ClassName = \"TextLabel\" ; Properties = { Text = Phantasm . createBinding ( \"Name\" , {}) }; }; }","title":"Binding a Property"},{"location":"guide/bindings-and-refs/#creating-a-binding","text":"To create a binding, define a data structure with keys for the Properties , ReturnType , Category , Description , and Run function like so: { Properties = { FormatString = { Type = \"string\" ; Default = \"OS Time: %s\" ; }; }; ReturnType = \"string\" ; Category = \"Time\" ; Description = \"Returns a formatted os.time string\" ; Run = function ( element , arguments ) return string.format ( arguments . FormatString , tostring ( os.time ())) end ; } The reason why ReturnType , Category , and Description should be provided is because they tell Phantasm's editor what it should return, what category it should be in, and what to display when hovering over it for the description. These are useful because it allows you to guarantee that a UI designer will only apply this binding to properties that it will work on, and that the designer knows what they are intended for. Similarly, the reason you need to define values in Properties as a table with a Type and Default is so that the editor can handle these appropriately and make sure they don't result in a binding being incorrectly applied.","title":"Creating a Binding"},{"location":"guide/bindings-and-refs/#refs","text":"While bindings are incredibly helpful for individual properties, we may often want to access or reference an entire Roblox Instance and its methods, or provide a specific element to a component to be used for some purpose. Refs are a special object that point to either an element's Roblox Instance or the element itself depending on the context. A ref will point to an element's Roblox instance when being used as an element's property, while it will point to the element itself if it is being used as a property for a component, binding, or function.","title":"Refs"},{"location":"guide/bindings-and-refs/#refs-in-action","text":"To use a ref, call Phantasm.createRef() and put the result somewhere persistent, such as within context or interfaceContext . An optional argument can also be provided to specify the element or the element's id to reference it to. { Init = function ( self , context , interfaceContext ) context . nextElement = phantasm . createRef () end ; } Finally, we create the elements in the component's Constructor . in NextElement, we use the special key Phantasm.Ref to allow us to tell the engine to automatically assign the reference at context.nextElement to NextElement so that it may be used by Element either in that call or the next (this depends on the order in which the elements are created). { Constructor = function ( self , context , interfaceContext ) return { Element = Phantasm . createElement ( \"TextButton\" , { NextSelectionLeft = context . nextElement ; }); NextElement = Phantasm . createElement ( \"TextButton\" , { [ Phantasm . Ref ] = context . nextElement ; }); } end ; } Info If you want to access a Ref from external code or via a higher/different component, you can specify it in the component's context and access it via componentName.Context","title":"Refs in Action"},{"location":"guide/components/","text":"Components are contained, reusable parts of your interface that you can combine to build a complete interface. Components accept custom properties, and return elements that should represent those properties to be placed within its container. Types of Components \u00b6 Function Components \u00b6 A function component is a component that was created from an element in the interface's or component's tree that was defined as a function. They're simply a function that returns a dynamic result. { function () return { Element1 = { ClassName = \"Frame\" ; Properties = { BackgroundColor3 = Color3 . new ( 0 , 0 , 0 ); }; }; } end ; } Dynamic Components \u00b6 A dynamic component is a component that has been defined in either the interface's components index, the engine's components folder, or the shared components folder in ReplicatedStorage.Phantasm { Properties = { Username = { Type = \"string\" ; Default = \"Robloxian\" ; }; }; Functions = { PrintUsername = function ( self ) print ( self . Username ) end ; }; InitialSize = UDim2 . new ( 0 , 80 , 0 , 20 ); Icon = \"\" ; Category = \"\" ; Description = \"\" ; Init = function ( self , context , interfaceContext ) print ( \"Initialized Hello!\" ) end ; PreRender = function ( self , context , interfaceContext ) end ; Constructor = function ( self , context , interfaceContext ) return { { ClassName = \"TextLabel\" ; Properties = { Text = \"Hello, \" .. self . Username .. \"!\" ; }; }; } end ; PostRender = function ( self , context , interfaceContext ) end ; } To explain what each of these means: Properties - A table with property definitions which defines what type the property is, what it's defaults are, and depending on the property, various other factors that the editor uses to display it properly. Functions - A table with function definitions which can be used as if they were a method of the component itself (ex: Component:PrintUsername() would fire the PrintUsername function in this table). InitialSize - The initial size of the component when it is inserted in the editor. Icon - The component's icon when displayed within the editor's Interface Explorer. Category - The component's category within the editor's Insert window. Description - The component's description when hovered over within the editor's Insert window or Interface Explorer. Init - A function called by the engine when initializing the component. PreRender - A function called by the engine right before the component is rendered. Constructor - A function to be called by the engine when rendering the component to determine how it should appear dynamically. PostRender - A function called by the engine right after the component has been rendered. Using Components \u00b6 In our previous examples, we simply passed the ClassName of a Roblox Instance as an index when defining an element in our interface. To define a component in our interface, we define the ClassName index as Component and specify what component we mean by defining the Component index as a string referring to the name of that component: { ClassName = \"Component\" ; Component = \"Hello\" ; Properties = { Username = \"Kamijou Touma\" ; }; } Info It is also possible to use components within other components! Warning Make sure to avoid defining circular components, as Phantasm has no protection against this it will continuously create more and more components within them until your client crashes! Improving our Incrementing Counter \u00b6 Now that we know how components work, we can revisit our incrementing counter example from the previous section and improve it using a function component. Changed sections have been highlighted. local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Phantasm = require ( ReplicatedStorage . PhantasmEngine ) local currentTime = 0 local interfaceData = { Elements = { -- Define a function component that represents our UI function () return { TimeLabel = { ClassName = \"TextLabel\" ; Properties = { Size = UDim2 . new ( 1 , 0 , 1 , 0 ); Text = \"Time Elapsed: \" .. currentTime }; }; } end ; }; } local interface = Phantasm . mountInterface ( interfaceData ) while true do wait ( 1 ) currentTime += 1 end Info If you want to try and take it a step further, why not try turning it into a reusable Dynamic Component on your own to learn how to use them!","title":"Components"},{"location":"guide/components/#types-of-components","text":"","title":"Types of Components"},{"location":"guide/components/#function-components","text":"A function component is a component that was created from an element in the interface's or component's tree that was defined as a function. They're simply a function that returns a dynamic result. { function () return { Element1 = { ClassName = \"Frame\" ; Properties = { BackgroundColor3 = Color3 . new ( 0 , 0 , 0 ); }; }; } end ; }","title":"Function Components"},{"location":"guide/components/#dynamic-components","text":"A dynamic component is a component that has been defined in either the interface's components index, the engine's components folder, or the shared components folder in ReplicatedStorage.Phantasm { Properties = { Username = { Type = \"string\" ; Default = \"Robloxian\" ; }; }; Functions = { PrintUsername = function ( self ) print ( self . Username ) end ; }; InitialSize = UDim2 . new ( 0 , 80 , 0 , 20 ); Icon = \"\" ; Category = \"\" ; Description = \"\" ; Init = function ( self , context , interfaceContext ) print ( \"Initialized Hello!\" ) end ; PreRender = function ( self , context , interfaceContext ) end ; Constructor = function ( self , context , interfaceContext ) return { { ClassName = \"TextLabel\" ; Properties = { Text = \"Hello, \" .. self . Username .. \"!\" ; }; }; } end ; PostRender = function ( self , context , interfaceContext ) end ; } To explain what each of these means: Properties - A table with property definitions which defines what type the property is, what it's defaults are, and depending on the property, various other factors that the editor uses to display it properly. Functions - A table with function definitions which can be used as if they were a method of the component itself (ex: Component:PrintUsername() would fire the PrintUsername function in this table). InitialSize - The initial size of the component when it is inserted in the editor. Icon - The component's icon when displayed within the editor's Interface Explorer. Category - The component's category within the editor's Insert window. Description - The component's description when hovered over within the editor's Insert window or Interface Explorer. Init - A function called by the engine when initializing the component. PreRender - A function called by the engine right before the component is rendered. Constructor - A function to be called by the engine when rendering the component to determine how it should appear dynamically. PostRender - A function called by the engine right after the component has been rendered.","title":"Dynamic Components"},{"location":"guide/components/#using-components","text":"In our previous examples, we simply passed the ClassName of a Roblox Instance as an index when defining an element in our interface. To define a component in our interface, we define the ClassName index as Component and specify what component we mean by defining the Component index as a string referring to the name of that component: { ClassName = \"Component\" ; Component = \"Hello\" ; Properties = { Username = \"Kamijou Touma\" ; }; } Info It is also possible to use components within other components! Warning Make sure to avoid defining circular components, as Phantasm has no protection against this it will continuously create more and more components within them until your client crashes!","title":"Using Components"},{"location":"guide/components/#improving-our-incrementing-counter","text":"Now that we know how components work, we can revisit our incrementing counter example from the previous section and improve it using a function component. Changed sections have been highlighted. local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Phantasm = require ( ReplicatedStorage . PhantasmEngine ) local currentTime = 0 local interfaceData = { Elements = { -- Define a function component that represents our UI function () return { TimeLabel = { ClassName = \"TextLabel\" ; Properties = { Size = UDim2 . new ( 1 , 0 , 1 , 0 ); Text = \"Time Elapsed: \" .. currentTime }; }; } end ; }; } local interface = Phantasm . mountInterface ( interfaceData ) while true do wait ( 1 ) currentTime += 1 end Info If you want to try and take it a step further, why not try turning it into a reusable Dynamic Component on your own to learn how to use them!","title":"Improving our Incrementing Counter"},{"location":"guide/elements/","text":"Everything in Phantasm is built out of elements. They are they smallest building blocks in the creation of UIs. Elements are what describe how you want your UI to look and behave at a singular point in time. While an Element can be changed via code like any other instance once the interface has been mounted, this is not advised and you would be better off either using a Binding for a property or creating a Component . Elements are automatically created based on the table structure provided in the Elements index of the interface's data. It requires a Roblox class name to be provided or, if using a component, a class name of \"Component\" and then provide the name of that component separately: local interfaceData = { Elements = { Element1 = { ClassName = \"Frame\" ; Properties = { Size = UDim2 . new ( 0 , 20 , 0 , 20 ); }; }; ComponentElement = { ClassName = \"Component\" ; Component = \"Slider\" ; Properties = { Size = UDim2 . new ( 0 , 50 , 0 , 15 ); Value = .4 ; }; }; }; } You can represent children of an Element by providing it with a Children index: local interfaceData = { Elements = { Element1 = { ClassName = \"Frame\" ; Properties = { Size = UDim2 . new ( 0 , 20 , 0 , 20 ); }; Children = { ChildElement = { ClassName = \"TextLabel\" ; Properties = { Text = \"Hello World!\" ; }; }; }; }; ComponentElement = { ClassName = \"Component\" ; Component = \"Slider\" ; Properties = { Size = UDim2 . new ( 0 , 50 , 0 , 15 ); Value = .4 ; }; Children = { ChildElement = { ClassName = \"TextLabel\" ; Properties = { Text = \"Components can have children too!\" ; }; }; }; }; }; } Defining the interface structure on its own doesn't do anything, however. In order to transform our interface structure into an actual, functioning interface with real Roblox instances, we need to call PhantasmEngine.mountInterface : local myInterface = PhantasmEngine . mountInterface ( interfaceData ) Mounting creates a new Interface object from the data you provide, and optionally if the second argument is provided, it will use the Instance provided as the container for all your interface's elements. If not provided, it will automatically generate a new ScreenGui which will be used as the container. PhantasmEngine.mountInterface returns the Interface object that can be later used to destroy it or get information from it with PhantasmEngine.demountInterface or indexing the Interface object. Changing What's Being Rendered \u00b6 In order to change the UI that has been created, it is as simple as getting the desired element in the interface and changing it's properties, which can be done in the same way you would an actual Roblox instance! The Interface object and all of the elements and components parented to it are designed so that you can interact with them just like you would an actual Roblox instance for the sake of convenience. Using myInterface from above, we can update the size and text of our label/frame: myInterface . Element1 . Size = UDim2 . new ( 0 , 50 , 0 , 20 ) myInterface . Element1 . ChildElement . Text = \"Hello Again World!\" Info It is generally not advised to interact with the interface directly like this unless it is absolutely necessary. You should use a Binding or Component instead. Demounting the Interface \u00b6 Phantasm provides a method called PhantasmEngine.demountInterface that can be used when we're done with our interface. PhantasmEngine . demountInterface ( myInterface ) Demounting destroys the Interface object, removes it from the render queue, and recursively destroys all the child elements and components, allowing the Roblox Instances those elements were occupying to be reused by other interfaces. Warning Trying to use an interface after it has been passed to PhantasmEngine.demountInterface will result in errors! Incrementing Counter \u00b6 Utilizing what we have covered so far, we can make a simple interface that tells you how long it has been running for. This is a full example that should work when put into a LocalScript in StarterPlayerScripts . It makes the assumption that Phantasm has been installed into ReplicatedStorage local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Phantasm = require ( ReplicatedStorage . PhantasmEngine ) local interfaceData = { Elements = { TimeLabel = { ClassName = \"TextLabel\" ; Properties = { Size = UDim2 . new ( 1 , 0 , 1 , 0 ); Text = \"Time Elapsed: 0\" ; }; }; }; } local currentTime = 0 local interface = Phantasm . mountInterface ( interfaceData ) while true do wait ( 1 ) currentTime += 1 interface . TimeLabel . Text = \"Time Elapsed: \" .. currentTime end In the next section, we'll cover components, which allow us to create reusable groups of elements, and introduce one of the two primary techniques to dynamically change UI in Phantasm.","title":"Elements"},{"location":"guide/elements/#changing-whats-being-rendered","text":"In order to change the UI that has been created, it is as simple as getting the desired element in the interface and changing it's properties, which can be done in the same way you would an actual Roblox instance! The Interface object and all of the elements and components parented to it are designed so that you can interact with them just like you would an actual Roblox instance for the sake of convenience. Using myInterface from above, we can update the size and text of our label/frame: myInterface . Element1 . Size = UDim2 . new ( 0 , 50 , 0 , 20 ) myInterface . Element1 . ChildElement . Text = \"Hello Again World!\" Info It is generally not advised to interact with the interface directly like this unless it is absolutely necessary. You should use a Binding or Component instead.","title":"Changing What's Being Rendered"},{"location":"guide/elements/#demounting-the-interface","text":"Phantasm provides a method called PhantasmEngine.demountInterface that can be used when we're done with our interface. PhantasmEngine . demountInterface ( myInterface ) Demounting destroys the Interface object, removes it from the render queue, and recursively destroys all the child elements and components, allowing the Roblox Instances those elements were occupying to be reused by other interfaces. Warning Trying to use an interface after it has been passed to PhantasmEngine.demountInterface will result in errors!","title":"Demounting the Interface"},{"location":"guide/elements/#incrementing-counter","text":"Utilizing what we have covered so far, we can make a simple interface that tells you how long it has been running for. This is a full example that should work when put into a LocalScript in StarterPlayerScripts . It makes the assumption that Phantasm has been installed into ReplicatedStorage local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Phantasm = require ( ReplicatedStorage . PhantasmEngine ) local interfaceData = { Elements = { TimeLabel = { ClassName = \"TextLabel\" ; Properties = { Size = UDim2 . new ( 1 , 0 , 1 , 0 ); Text = \"Time Elapsed: 0\" ; }; }; }; } local currentTime = 0 local interface = Phantasm . mountInterface ( interfaceData ) while true do wait ( 1 ) currentTime += 1 interface . TimeLabel . Text = \"Time Elapsed: \" .. currentTime end In the next section, we'll cover components, which allow us to create reusable groups of elements, and introduce one of the two primary techniques to dynamically change UI in Phantasm.","title":"Incrementing Counter"},{"location":"guide/events/","text":"Phantasm handles Instance event connections automatically as part of the rendering process. To connect an event, simply pass a property with Phantasm.Event.EVENT_NAME as the key and a function as the value. Phantasm will automatically connect this function to the event for you and will pass the element that the event is connected to as the first argument to the callback, followed by any arguments that Roblox passed. { ClassName = \"TextButton\" Properties = { Text = \"Click me I beg you!\" ; Size = UDim2 . new ( 0 , 200 , 0 , 80 ); [ Phantasm . Event . Activated ] = function () print ( \"The button has been clicked!\" ) end ; }; } To listen for GetPropertyChangedSignal , Phantasm provides a similar API, using properties with Phantasm.Changed.PROPERTY_NAME as their key: { ClassName = \"TextButton\" Properties = { Text = \"Click me I beg you!\" ; Size = UDim2 . new ( 0 , 200 , 0 , 80 ); [ Phantasm . Changed . AbsoluteSize ] = function ( element ) print ( \"Absolute size has changed to\" , element . AbsoluteSize ) end ; }; } Info Events will automatically be disconnect when the element is destroyed! Warning There is currently debate around whether or not an event should be defined using a custom Event type as a key instead of directly referencing the event's name so this may be subject to change in a future version. As of right now, there exists no method to listen to GetPropertyChangedSignal , which was an oversight during the original creation of the engine and has plans to be fixed in the future.","title":"Events"},{"location":"guide/functions/","text":"WIP","title":"Functions"},{"location":"guide/installation/","text":"Phantasm has two supported ways to get started with. Method 1: Model File (via Roblox Studio) \u00b6 Download the rbxm model file attached with the latest release from the Github releases page Import the model file into Studio into a location like ReplicatedStorage Method 2: Filesystem \u00b6 Copy the src.PhantasmEngine directory into your codebase Use a plugin like Rojo to sync the files into your place","title":"Installation"},{"location":"guide/installation/#method-1-model-file-via-roblox-studio","text":"Download the rbxm model file attached with the latest release from the Github releases page Import the model file into Studio into a location like ReplicatedStorage","title":"Method 1: Model File (via Roblox Studio)"},{"location":"guide/installation/#method-2-filesystem","text":"Copy the src.PhantasmEngine directory into your codebase Use a plugin like Rojo to sync the files into your place","title":"Method 2: Filesystem"},{"location":"guide/interface-structure/","text":"Before anything else, you should learn about how interfaces are structured. A standard interface may look like this: { Theme = \"MyThemeName\" ; Enabled = true ; Bindings = {}; Functions = {}; Components = {}; Elements = {}; Animations = {}; } In this example interface, Theme represents either the name of the theme you wish your interface's elements to pull their default properties from, or directly providing the theme right there. Enabled is simply a property to set on the ScreenGui object that is generated by default if you do not provide a parent container for the interface to use. Bindings holds all the bindings that are bundled within that specific interface and are not provided from either the engine itself or the public Bindings folder located in ReplicatedStorage.Phantasm For the rest of the table properties, it is the same as Bindings with the exception of Elements , which is a mandatory key in your interface as it determines what Elements and Components are within your interface. Every key except for Elements is optional and will be filled in with a default by the engine if not provided.","title":"Interface Structure"}]}